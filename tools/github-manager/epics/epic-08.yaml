title: "â­ Epic 8: Slice Vertical: Batalha"
state: "open"
sub-issues:
  - title: "Story 8.1: ConfiguraÃ§Ã£o Inicial da Batalha"
    type: "ğŸ“– Feature / Story"
    state: "open"
    description: |
      Como jogador, quero que a batalha comece com meus personagens e inimigos posicionados na grid para que o combate possa ser iniciado.
    sub-issues:
      - title: "ğŸ“ Task 8.1.1 Definir Locais VÃ¡lidos para Spawn de Inimigos na Grid de Batalha"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Esta tarefa envolve especificar o conjunto de coordenadas na grid de batalha onde os personagens inimigos podem ser colocados programaticamente no inÃ­cio de uma batalha. Isso pode ser gerenciado adicionando um array de Vector2i ao script do GridController ou a um recurso BattleConfig dedicado, configurÃ¡vel atravÃ©s do Inspetor do Godot. Estes pontos garantirÃ£o que os inimigos apareÃ§am nas Ã¡reas pretendidas.
      - title: "ğŸ“ Task 8.1.2: Implementar InstanciaÃ§Ã£o e Posicionamento de Inimigos no BattleController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Modificar o script BattleController.cs. Quando uma batalha comeÃ§ar, este script deve ser responsÃ¡vel por criar instÃ¢ncias de personagens inimigos (provavelmente de uma PackedScene ou recurso CharacterType) e entÃ£o posicionar estas instÃ¢ncias na grid de batalha em um dos locais de spawn vÃ¡lidos definidos na Tarefa 8.1.1.
      - title: "ğŸ“ Task 8.1.3: Registrar Inimigos Instanciados no TurnController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          ApÃ³s os personagens inimigos serem instanciados e posicionados na grid pelo BattleController, eles devem ser registrados no TurnController.cs. Isso garante que eles sejam adicionados Ã  fila de turnos e participem do fluxo de turnos da batalha.

  - title: "Story 8.2: Gerenciamento de Energia por Dados"
    type: "ğŸ“– Feature / Story"
    state: "open"
    description: |
      Como personagem, quero rolar meus dados no inÃ­cio do meu turno para ganhar energia e poder usÃ¡-la em aÃ§Ãµes.
    sub-issues:
      - title: "ğŸ“ Task 8.2.1: Configurar Recursos CharacterType com Recursos DiceType PrÃ©-definidos"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Para cada recurso CharacterType.tres que serÃ¡ usado para personagens jogadores e inimigos, use o Inspetor do Godot para atribuir recursos DiceType.tres especÃ­ficos Ã  sua propriedade EquippedDice (ou equivalente). Isso define quais dados cada tipo de personagem rolarÃ¡ para gerar energia.
      - title: "ğŸ“ Task 8.2.2: Implementar LÃ³gica de Rolagem de Dados no InÃ­cio do Turno do Personagem Jogador no TurnController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Modificar TurnController.cs. Quando for determinado que o turno de um personagem controlado pelo jogador estÃ¡ comeÃ§ando, o controlador deve acionar o mecanismo de rolagem de dados para aquele personagem. Isso envolve chamar o mÃ©todo existente CharacterType.RollEquippedDiceForEnergy() ou uma funÃ§Ã£o similar associada ao personagem ativo para simular a rolagem dos dados.
      - title: "ğŸ“ Task 8.2.3: Atualizar Atributo de Energia Atual do Personagem Baseado no Resultado da Rolagem de Dados"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          ApÃ³s os dados serem rolados (conforme Tarefa 8.2.2), o valor de energia resultante precisa atualizar o pool de energia atual do personagem ativo. Isso tipicamente envolve modificar um atributo de energia dentro de um componente CharacterStats.cs ou uma estrutura de dados em tempo de execuÃ§Ã£o associada ao CharacterType.
      - title: "ğŸ“ Task 8.2.4: Implementar SubtraÃ§Ã£o de Custo de Energia para AÃ§Ãµes no ActionsController ou CharacterStats"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Quando um personagem executa uma aÃ§Ã£o que tem um custo de energia (definido em seu recurso ActionType), o sistema deve subtrair este custo do pool de energia atual do personagem. Esta lÃ³gica deve ser implementada dentro do ActionsController.cs (quando uma aÃ§Ã£o Ã© processada) ou usando o CharacterService.

  - title: "Story 8.3: Ciclo BÃ¡sico de Round e Turnos"
    type: "ğŸ“– Feature / Story"
    state: "open"
    description: |
      Como sistema, quero gerenciar a progressÃ£o dos turnos e rounds de forma ordenada para que a batalha siga uma estrutura lÃ³gica.
    sub-issues:
      - title: "ğŸ“ Task 8.3.1: Implementar CÃ¡lculo de Iniciativa e DefiniÃ§Ã£o da Ordem Inicial de Turnos no TurnController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Aprimorar TurnController.cs para calcular uma pontuaÃ§Ã£o de iniciativa para cada personagem participante da batalha no seu inÃ­cio. Baseado nestas pontuaÃ§Ãµes (ex: maior iniciativa vai primeiro), o controlador estabelecerÃ¡ a sequÃªncia inicial de turnos para o primeiro round.
      - title: "ğŸ“ Task 8.3.2: Implementar ProgressÃ£o de Turno para o PrÃ³ximo Personagem no TurnController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Dentro de TurnController.cs, implementar o mecanismo central para avanÃ§ar o estado da batalha do turno do personagem atual para o prÃ³ximo personagem na fila de ordem de turno prÃ©-definida. Isso envolve desativar o personagem atual e ativar o prÃ³ximo.
      - title: "ğŸ“ Task 8.3.3: Implementar DetecÃ§Ã£o de Fim de Round e InÃ­cio do PrÃ³ximo Round no RoundController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Desenvolver lÃ³gica dentro de RoundController.cs (ou TurnController se os rounds forem gerenciados lÃ¡) para detectar quando cada personagem na ordem de turno completou seu turno para o round atual. ApÃ³s a detecÃ§Ã£o, o controlador deve acionar os processos necessÃ¡rios para concluir o round atual e iniciar um novo (ex: resetar ordem de turno se a iniciativa for rolada novamente, aplicar efeitos baseados no round).

  - title: "Story 8.4: CondiÃ§Ãµes de Fim de Batalha"
    type: "ğŸ“– Feature / Story"
    state: "open"
    description: |
      Como sistema, quero detectar o fim da batalha quando um dos lados for completamente derrotado para declarar um vencedor.
    sub-issues:
      - title: "ğŸ“ Task 8.4.1: Implementar VerificaÃ§Ãµes de CondiÃ§Ã£o de Fim de Batalha por Derrota de Equipe"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Implementar um sistema que, tipicamente apÃ³s cada aÃ§Ã£o ser resolvida ou ao final do turno de cada personagem, verifica o status de todos os personagens. Se todos os personagens pertencentes a uma equipe (todos os personagens jogadores ou todos os personagens inimigos) foram derrotados (ex: seu HP estÃ¡ em ou abaixo de 0), uma condiÃ§Ã£o de fim de batalha Ã© atendida.
      - title: "ğŸ“ Task 8.4.2: Chamar BattleResultsController e Passar Resultado ao Fim da Batalha"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Uma vez que uma condiÃ§Ã£o de fim de batalha (da Tarefa 8.4.1) Ã© detectada, o sistema (provavelmente o BattleController ou TurnController) deve invocar o BattleResultsController.cs. Esta chamada deve incluir informaÃ§Ã£o sobre o resultado da batalha (ex: um enum indicando VitÃ³ria do Jogador ou Derrota do Jogador).
      - title: "ğŸ“ Task 8.4.3: Implementar ExibiÃ§Ã£o BÃ¡sica de Resultado da Batalha no BattleResultsController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Em BattleResultsController.cs, adicionar lÃ³gica inicial para apresentar o resultado da batalha ao jogador. Para esta fatia mÃ­nima, isso pode ser tÃ£o simples quanto imprimir "VitÃ³ria!" ou "Derrota!" no console do Godot ou exibir um rÃ³tulo de UI bÃ¡sico e nÃ£o interativo na tela.