title: "â­ Epic 8: Slice Vertical: Batalha"
state: "open"
description: |
  Implementar o fluxo completo de uma batalha, desde o setup inicial dos personagens e inimigos, gerenciamento de energia atravÃ©s de dados, o ciclo de rounds e turnos, atÃ© as condiÃ§Ãµes de finalizaÃ§Ã£o da batalha e apresentaÃ§Ã£o do resultado.
sub-issues:
  - title: "ğŸ“– Story 8.1: Setup Inicial da Batalha"
    type: "ğŸ“– Feature / Story"
    state: "open"
    description: |
      Como jogador, quero que a batalha comece com meus personagens e inimigos posicionados na grid para que o combate possa ser iniciado.
    sub-issues:
      - title: "ğŸ“ Task 8.1.1: Definir locais para os personagens na grid de batalha"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          - Os personagens do jogador precisam ser posicionados de acordo com a configuraÃ§Ã£o deles na equipe do player (PlayerSquad).
          - Especificar o conjunto de coordenadas na grid de batalha onde os inimigos podem ser colocados programaticamente no inÃ­cio de uma batalha.
      - title: "ğŸ“ Task 8.1.2: Implementar InstanciaÃ§Ã£o e Posicionamento de Inimigos no BattleController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Modificar o script BattleController.cs. Quando uma batalha comeÃ§ar, este script deve ser responsÃ¡vel por criar instÃ¢ncias de personagens inimigos (provavelmente de uma PackedScene ou recurso CharacterType) e entÃ£o posicionar estas instÃ¢ncias na grid de batalha em um dos locais de spawn vÃ¡lidos definidos na Tarefa 8.1.1.
      - title: "ğŸ“ Task 8.1.3: Registrar Inimigos Instanciados no TurnController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          ApÃ³s os personagens inimigos serem instanciados e posicionados na grid pelo BattleController, eles devem ser registrados no TurnController.cs. Isso garante que eles sejam adicionados Ã  fila de turnos e participem do fluxo de turnos da batalha.

  - title: "ğŸ“– Story 8.2: Gerenciamento de Energia"
    type: "ğŸ“– Feature / Story"
    state: "open"
    description: |
      Como personagem, quero rolar meus dados no inÃ­cio do meu turno para ganhar energia e poder usÃ¡-la em aÃ§Ãµes.
    sub-issues:
      - title: "ğŸ“ Task 8.2.1: Configurar Recursos CharacterType com Recursos DiceType PrÃ©-definidos"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Para cada recurso CharacterType.tres que serÃ¡ usado para personagens jogadores e inimigos, use o Inspetor do Godot para atribuir recursos DiceType.tres especÃ­ficos Ã  sua propriedade EquippedDice (ou equivalente). Isso define quais dados cada tipo de personagem rolarÃ¡ para gerar energia.
      - title: "ğŸ“ Task 8.2.2: Implementar lÃ³gica de rolagem de dados no inÃ­cio do turno do personagem do jogador no ActionsController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Modificar TurnController.cs. Quando for determinado que o turno de um personagem controlado pelo jogador estÃ¡ comeÃ§ando, o controlador deve acionar o mecanismo de rolagem de dados para aquele personagem. Isso envolve chamar o mÃ©todo existente CharacterType.RollEquippedDiceForEnergy() ou uma funÃ§Ã£o similar associada ao personagem ativo para simular a rolagem dos dados.
      - title: "ğŸ“ Task 8.2.3: Atualizar a energia atual do personagem baseado no resultado da Rolagem de Dados"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          ApÃ³s os dados serem rolados (conforme Tarefa 8.2.2), o valor de energia resultante precisa atualizar o pool de energia atual do personagem ativo. Isso tipicamente envolve modificar um atributo de energia dentro de um componente CharacterStats.cs ou uma estrutura de dados em tempo de execuÃ§Ã£o associada ao CharacterType.
      - title: "ğŸ“ Task 8.2.4: Implementar subtraÃ§Ã£o de custo de energia para aÃ§Ãµes no ActionsController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Quando um personagem executa uma aÃ§Ã£o que tem um custo de energia (definido em seu recurso ActionType), o sistema deve subtrair este custo do pool de energia atual do personagem. Esta lÃ³gica deve ser implementada dentro do ActionsController.cs (quando uma aÃ§Ã£o Ã© processada) ou usando o CharacterService.

  - title: "ğŸ“– Story 8.3: Ciclo BÃ¡sico de Round e Turnos"
    type: "ğŸ“– Feature / Story"
    state: "open"
    description: |
      Como sistema, quero gerenciar a progressÃ£o dos turnos e rounds de forma ordenada para que a batalha siga uma estrutura lÃ³gica.
    sub-issues:
      - title: "ğŸ“ Task 8.3.1: Implementar cÃ¡lculo de iniciativa e definiÃ§Ã£o da ordem Inicial de turnos no TurnController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Aprimorar TurnController.cs para calcular uma pontuaÃ§Ã£o de iniciativa para cada personagem participante da batalha no seu inÃ­cio. Baseado nestas pontuaÃ§Ãµes (ex: maior iniciativa vai primeiro), o controlador estabelecerÃ¡ a sequÃªncia inicial de turnos para o primeiro round.
      - title: "ğŸ“ Task 8.3.2: Implementar progressÃ£o de turno para o prÃ³ximo personagem no TurnController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Dentro de TurnController.cs, implementar o mecanismo central para avanÃ§ar o estado da batalha do turno do personagem atual para o prÃ³ximo personagem na fila de ordem de turno prÃ©-definida. Isso envolve desativar o personagem atual e ativar o prÃ³ximo.
      - title: "ğŸ“ Task 8.3.3: Implementar DetecÃ§Ã£o de Fim de Round e InÃ­cio do PrÃ³ximo Round no RoundController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Desenvolver lÃ³gica dentro de RoundController.cs (ou TurnController se os rounds forem gerenciados lÃ¡) para detectar quando cada personagem na ordem de turno completou seu turno para o round atual. ApÃ³s a detecÃ§Ã£o, o controlador deve acionar os processos necessÃ¡rios para concluir o round atual e iniciar um novo (ex: resetar ordem de turno se a iniciativa for rolada novamente, aplicar efeitos baseados no round).

  - title: "ğŸ“– Story 8.4: CondiÃ§Ãµes de Fim de Batalha"
    type: "ğŸ“– Feature / Story"
    state: "open"
    description: |
      Como sistema, quero detectar o fim da batalha quando um dos lados for completamente derrotado para declarar um vencedor.
    sub-issues:
      - title: "ğŸ“ Task 8.4.1: Implementar verificaÃ§Ãµes de condiÃ§Ã£o dd fim da batalha na derrota de equipe"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Implementar um sistema que, tipicamente apÃ³s cada aÃ§Ã£o ser resolvida ou ao final do turno de cada personagem, verifica o status de todos os personagens. Se todos os personagens pertencentes a uma equipe (todos os personagens jogadores ou todos os personagens inimigos) foram derrotados (ex: seu HP estÃ¡ em ou abaixo de 0), uma condiÃ§Ã£o de fim de batalha Ã© atendida.
      - title: "ğŸ“ Task 8.4.2: Chamar BattleResultsController e Passar Resultado ao Fim da Batalha"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Uma vez que uma condiÃ§Ã£o de fim de batalha (da Tarefa 8.4.1) Ã© detectada, o sistema (provavelmente o BattleController ou TurnController) deve invocar o BattleResultsController.cs. Esta chamada deve incluir informaÃ§Ã£o sobre o resultado da batalha (ex: um enum indicando VitÃ³ria do Jogador ou Derrota do Jogador).
      - title: "ğŸ“ Task 8.4.3: Implementar exibiÃ§Ã£o bÃ¡sica de resultado da batalha no BattleResultsController"
        type: "ğŸ“ Task"
        state: "open"
        description: |
          Em `BattleResultsController.cs`, adicionar lÃ³gica inicial para apresentar o resultado da batalha ao jogador. Isso pode ser tÃ£o simples quanto imprimir "VitÃ³ria!" ou "Derrota!" no console do Godot ou exibir uma label bÃ¡sica e nÃ£o interativo na tela.